Библиотека работы с USB модулем микроконтроллеров MSP430
========================================================
Copyright (c) 2015 kiv.apple@gmail.com
Лицензия - LGPLv2. Вы можете использовать и распространять этот код на условиях этой лицензии,
но автор не даёт никаких гарантий и не несёт никакой ответственности.
========================================================

void usbInit(int connect);

Вы должны вызвать эту функцию перед любой работой с USB. Эта функция выполняет
инициализацию USB модуля. Если connect=1, то после инициализации устройство сразу же
будет опознано компьютером (прерывания должны быть разрешены).

void usbConnect();

Вы должны вызвать эту функцию перед любой работой с USB, если передали connect=0
при вызове usbInit. После этой функции устройство станет видимым для компьютера
(прерывания должны быть разрешены).

void usbEp0SendResponse(const void *buffer, unsigned int len);

Отправка данных в ответ на IN-запрос к конечной точке 0. Данные могут быть больше,
чем размер буфера нулевой конечной точки (8 байт), в таком случае они будут отправлены
по частям, однако буфер должен быть в памяти до конца отправки сообщения. В случае
если отправляется не более 8 байт, то буфер может быть и локальной переменной функции,
потому что первый блок usbEp0SendResponse отправляет сама.

void usbEp0SendNull();

Отправка с нулевой конечной точки пакета нулевой длины.

void usbEp0SendStall();

Отправка состояния STALL с нулевой конечной точки. Обычно это состояние используется,
чтобы показать, что запрос не поддерживается.

void usbEp0EnableRecv();

Разрешение приёма данных нулевой конечной точкой. В этом случае при приходе данных будет
вызываться соответствующий callback.

void usbEpSetup(uint8_t ep, uint8_t bufferSize, int doubleBuf);

Настройка конечной точки отличной от нулевой. Следует добавить к номеру USB_ENDPOINT_IN или
USB_ENDPOINT_OUT в зависимости от того, какую конечную точку вы хотите настроить (IN или OUT).
bufferSize задаёт размер буфера, doubleBuf=1 включает двойную буферизацию (потребуется в 2 раза
больше памяти). Память для буферов выделяется автоматически. При смене конфигурации или
сбросе USB все конечные точки кроме 0 отключаются, память из-под их буферов освобождается.
Следует помнить, что модуль USB поддерживает только 8 конечных точек каждого типа
(таким образом номер может быть от 1 до 7, проверки на корректность не производятся).
Также следует помнить, что размер аппаратного буфера для конечных точек составляет 1904 байта.
Суммарный размер буферов всех конечных точек в текущей конфигурации не должен превышать это
значение.

void usbEpSendData(uint8_t ep, const void *data, uint8_t len);

Отправка данных с конечной точки. Требования к номеру конечной точки аналогичны usbEpSetup,
однако принимаются лишь точки типа IN. Длина отсылаемых данных не может превосходить размер
буфера конечной точки, который был передан usbEpSetup, иначе случится сбой модуля USB.
Данные из буфера используются сразу же при вызове, поэтому могут быть локальными переменными.
Конечная точка 0 тоже поддерживается, однако вызов usbEp0SendResponse предпочтительнее.

void usbEpSendNull(uint8_t ep);

Отправка пакета нулевой длины с конечной точки ep. Требования к номеру точки аналогичны
требованиям к usbEpSendData.

void usbEpSendStall(uint8_t ep);

Отправка состояния STALL с конечной точки ep. Требования к номеру точки аналогичны требованиям
к usbEpSendData.

void usbEpEnableRecv(uint8_t ep);

Разрешение получения OUT запросов конечной точкой ep.

int usbEpBusy(uint8_t ep);

Определение занятости конечной точки ep. Требования к номеру конечной точки аналогичны требованиям
к usbEpSendData. Возвращает 1 в случае, если буфер данных точки заполнен и 0 в противном случае.

Для реакции на различные события предусмотрены функции обратного вызова. Необходимость их вызова определяется
с помощью макропределений в usbconfig.h. Любая из этих функций может вызываться внутри обработчика прерывания.

#define USB_RESET_HANDLER
void usbResetHandler();

Если данное макроопределение активно, вы должны описать в своём коде функцию usbResetHandler. Она будет вызвана
при программном или аппаратном сбросе USB. Вызывается в ходе подключения устройства к компьютеру в том числе.

#define USB_SUSPEND_HANDLER
void usbSuspendHandler();

Вызывается при переходе USB в спящий режим. Может быть использована для включения энергосбережения микроконтроллера.

#define USB_RESUME_HANDLER
void usbResumeHandler();

Вызывается при возврате USB из спящего режима. Может быть использована для отключения энергосбережения микроконтроллера.

#define USB_SETUP_REQUEST_HANDLER
void usbSetupRequestHandler(USB_DEVICE_REQUEST *rq);

Стандартные SETUP-запросы обрабатываются драйвером USB, однако все CLASS и VENDOR запросы должны обрабатывать вы.
За подробным описанием структуры запросов обратитесь к спецификации USB.

#define USB_SET_CONFIGURATION_HANDLER
void usbSetConfigurationHandler();

Обработка установки конфигурации USB. Текущую конфигурацию можно узнать из глобальной переменной usb_configuration.
Ненулевое значение показывает, что устройство готово к работе. В этот момент вам следует настроить необходимые конечные точки
с помощью usbEpSetup (все кроме нулевой не активны по умолчанию). Если у вашего устройства несколько возможных конфигураций,
описанных в дескрипторах, то вам следует определить по номеру конфигурации, какие конечные точки настраивать.

#define USB_SET_ADDRESS_HANDLER
void usbSetAddressHandler(uint8_t addr);

Вызывается, когда устройство успешно определено компьютером и ему присвоен адрес.

#define USB_GET_DESCRIPTOR_HOOK
int usbGetDescriptorHook(USB_DEVICE_REQUEST *rq);

Вызывается перед стандартным обработчиком запроса дескриптора. С помощью usbEp0SendResponse вы можете вернуть
свой дескриптор, номер которого определяется с помощью rq->wIndex. Если вернуть ненулевое значение, то стандартный
обработчик вызван не будет. Стандартный обработчик автоматически возвращает STALL, если запрошенный дескриптор ему не известен.

#define USB_EP0_WRITE_HANDLER
int usbEp0WriteHandler(void *data, uint8_t len);

Обрабатывает OUT запросы к нулевой конечной точке. При этом data указывает на буфер USB, а len на длину полученных
данных (не больше 8 байт). Если данные получены не все, то следует вернуть ненулевое значение, в таком случае ожидание
данных будет продолжено и функция может быть вызвана снова. Если вернуть нулевое значение, то до следующего вызова
usbEp0EnableRecv все запросы записи будут проигнорированы. Вы можете использовать это, если нужно получить более 8 байт данных.

#define USB_ENDPOINT_IN_HANDLER
void usbEndpointInHandler(uint8_t ep);

Вызывается при окончании отправки данных с ненулевой конечной точки номер ep. При этом добавления константы
USB_ENDPOINT_IN не происходит. Вы можете отправить следующий пакет данных с помощью usbEpSendData и usbEpSendNull или
сообщить об ошибке с помощью usbEpSendStall.

#define USB_ENDPOINT_OUT_HANDLER
int usbEndpointOutHandler(uint8_t ep, void *data, uint8_t len);

Вызывается при получении данных ненулевой конечной точкой. len никогда не превышает размер буфера, заданного при
вызыво usbEpSetup. При возрате ненулевого значения приём данных продолжается, иначе все последующие запросы к этой
конечной точке будут проигнорированы до следующего вызова usbEpEnableRecv.

Вы должны описать некоторые дескрипторы в usbconfig.h. Во-первых, это дескриптор устройства - глобальная переменная
типа USB_DEVICE_DESCR. Во-вторых, дескрипторы конфигурации. Их количество задаётся с помощью константы USB_CONFIG_COUNT.
Пока требуется описывать глобальную переменную usb_config1_descr, однако в будущем будет поддерживаться и несколько
конфигураций. И, наконец, драйвер USB поддерживает строковые дескрипторы. Их количество задаётся с помощью
константы USB_STRING_COUNT. Указатели на каждый из них помещаются в массив usb_string_descr. Индекс дескриптора соответствует
его индексу в массиве. При описании дескрипторов вы можете использовать структуры и константы из usb.h. Если вы хотите
использовать дескрипторы, которые не поддерживаются стандартным драйвером (например, дескрипторы HID-устройств),
то вам следует обработать запросы на их получение в usbGetDescriptorHook.
